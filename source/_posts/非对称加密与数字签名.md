---
title: 非对称加密与数字签名
tags:
  - 加密，非对称，签名
categories:
  - 笔记
date: 2021-10-11 11:14:25
---


## 加密

在如今的互联网世界中，我们不可避免的会传输敏感信息：服务器的账户密码，身份证号，或者仅仅是你想和某人说话，不想让其他人听见。那如何实现安全、有效的向对方传输信息呢？这就需要对信息进行加密。接下来我将通过一个例子进行表述：

### 无加密

想象一下，`A` 要给 `B` 发送消息 `Hello` 。刚开始对信息没有任何加密

![image-20211011111533617](https://cdn.jsdelivr.net/gh/KJohn2q/John-s-figure-bed/image/202110111115034.png)

此时，因为没有加密，不怀好意的 `C`, 能看到 `A` 给 `B` 发送的信息内容   

![image-20211013113841872](https://cdn.jsdelivr.net/gh/KJohn2q/John-s-figure-bed/image/202110131138930.png)

### 对称加密

`A` 意识了此问题， 选择了算法 `AES`, 密码 `123456` 对信息内容进行加密，以 `Hello` 为例， 加密后的内容为： `U2FsdGVkX19E9T4t8hqL472J1jXdiDV7P9UZmM8LrNs=` 。`B` 在收到信息后，选择同样的算法和密码，对信息解密，得到真实的内容。而不怀好意的 `C` 即使看到了信息，因为没有密钥，看不到真实的内容。

![image-20211013120142096](https://cdn.jsdelivr.net/gh/KJohn2q/John-s-figure-bed/image/202110131201196.png)

为什么需要用到加密算法，而不是仅仅使用密码呢？这是因为仅仅只使用简单的密码（如：`123456`）,很容易被暴力破解。而复杂的，随机程度高且冗长的密码，又不易于记忆。使用加密算法配合密码能保证信息的单向加密，即加密过程简单，而反过来很难。

以上这种用同一密钥进行加解密的方式称之为**对称加密**。看起来很好，对吗？不过对称加密存在一个问题，发送者需要提前将**密钥**发送给信息接受者，使得在对方收到信息后，能对信息解密，得到真实的信息内容。而将密钥发送给接受者这一过程，有可能会被不怀好意的人拿到密钥。同时，如果需要给多人发送信息，则需要进行多次的密钥交换。

###  非对称加密

这时就需要用到**非对称加密**了。非对称加密指的是：使用一个密钥对对信息进行加密和解密。一个是公钥，一个是私钥，两者彼此独立，又相互关联。私钥，顾名思义，是私有的，由密钥创建人进行妥善保管。而公钥，可以发给任何一个你想要与之进行联系的人。回到刚刚那个例子： `A` 需要和 `B` 进行通信， 则 `B` 可以生成一对密钥，将公钥发给 `A`, 然后 `A` 用 `B` 的公钥对信息进行加密后发送， `B` 在收到信息后，使用自己的私钥对信息进行解密，得到真实的内容。

![image-20211013151949326](https://cdn.jsdelivr.net/gh/KJohn2q/John-s-figure-bed/image/202110131519396.png)

`B` 的私钥是只有 `B` 能看到，故`C` 看不到信息的真实内容。

## 数字签名

之前提到了，`B` 生成一对密钥，可以将公钥发给任何想要合作的人。而私钥则自己保留。假如 `B` 要发给 `D` 一份文档，`D` 在收到文档后，如何确定该文档没有被别人修改过呢？可以通过对文档或其他数据进行 **数字签名** 。**数字签名** 表示对文档进行盖戳，该戳可以证明 `B` 的身份，且难以被伪造。此外，签名可以保证文档没有被修改过。

要对文档进行数字签名，需要先对文档进行散列，生成一个字符串（不同的散列算法，生成的字符串长度也不同）。该字符串称之为“信息摘要”。将摘要回退到原始数据几乎不可能。

![image-20211105090501170](https://cdn.jsdelivr.net/gh/KJohn2q/John-s-figure-bed/image/202111050905322.png)

接下来，`B` 可以使用自己的私钥对信息摘要进行加密，结果即为签名。

![image-20211105091350680](https://cdn.jsdelivr.net/gh/KJohn2q/John-s-figure-bed/image/202111050913726.png)

接下来， `B` 可以将签名和原文档一并发给 `D`.

`D` 在收到后先使用公钥对数字签名进行解密，得到信息摘要。同时对文档进行散列，得到信息摘要。将两步得到的信息摘要进行对比，如相同，则可确定收到的文档没有被修改过。

![image-20211105092542040](https://cdn.jsdelivr.net/gh/KJohn2q/John-s-figure-bed/image/202111050925095.png)

现在有不怀好意的 `E` 知道 `D` 收到了 `B` 发给的文档和 `B` 的公钥。`E` 使用 `B` 的名字给 `D`  发送了自己的公钥，`D` 如何确保 `B` 的公钥是真实的呢？

于是就出现了证书颁发机构。`B` 可以在该机构中注册证书，其中包括 `B`的公钥及 `B` 的其他信息。证书颁发机构可在 `B` 的私钥丢失或不再使用时，撤销证书。同时有其他机构对证书颁发机构进行监督和管理。

![image-20211105101210715](https://cdn.jsdelivr.net/gh/KJohn2q/John-s-figure-bed/image/202111051012780.png)

现在，如 `B` 再要发送文档给 `D`， 则`D` 在收到文档后，可以先用证书颁发机构的公钥验证证书的有效性。如证书有效，可以拿到 `B` 的公钥，然后使用公钥来继续上面提到的验证操作。这样就保证了 `B` 公钥的真实性，避免其它人冒充 `B`.

## 引用

* [What is a Digital Signature?](http://www.youdzone.com/signature.html)